# 트랜잭션 

트랜잭션은 DBMS 에서 데이터를 다루는 논리적인 작업의 단위이다. (DBMS 의 작업 단위)

## 트랜잭션의 개념 
```
- 트랜잭션은 데이터베이스 장애 발생시 데이터를 복구하는 작업의 단위가 된다.
- 데이터베이스에서 여러 작업이 동시에 같은 데이터를 다룰 때 트랜잭션은 이 작업을 서로 분리하는 단위가 된다.
- 트랜잭션은 전체가 수행되거나 또는 전혀 수행되지 않아야 한다.

참고로 데이터베이스의 데이터는 하드디스크에 저장되어 있으며, 데이터는 주기억장치 버퍼로 사본을 읽어와서 처리한다.
즉 데이터 작업은 주기억장치에서 수행되고 난 후에 하드디스크에 기록된다.
```
#### + MySQL 에서 트랜잭션이 처리되는 과정
```
START TRANSACTION 커맨드로 트랜잭션을 시작한다.(데이터 사본을 읽어온다.) -> 데이터 변경 작업 수행 -> 부분 완료(COMMIT)
-> 버퍼의 변경 내용을 하드디스크에 기록 -> 완료(COMMIT)

DBMS 는 부분완료까지 작업을 수행한 후 사용자에게 완료 사실을 알린다. 그리고 버퍼의 변경 내용을 하드디스크에 기록하는 작업은
따로 수행한다.

왜냐하면 DBMS 에서 동시에 많은 트랜잭션 수행시 각각의 트랜잭션 마다 하드디스크에 개별 접근하면 성능이 떨어지기 때문에
하드디스크에 접근하는 것을 일괄적으로 처리함으로써 사용자에게 빠른 응답성을 보장한다. 
```
### 트랜잭션의 성질 
```
* 원자성 Atomictiy

트랜잭션에 포함된 작업은 전부 수행되거나 아니면 전부 수행되지 않아야 한다.

MySQL 에서는 트랜잭션 제어 커맨드를 사용해서 트랜잭션을 수동으로 시작하거나 또는 데이터를 변경하는 SQL 문이 나오면 자동으로
트랜잭션이 시작된다.

트랜잭션 종료는 직접 COMMIT 또는 ROLLBACK 문을 사용하거나 후자의 경우 DDL 문을 만날 때 자동으로 종료된다.

SAVE 문을 사용해서 세이브 포인트를 만들 수도 있다. 트랜잭션이 잘못 됐을 때 처음부터 다시 시작하지 않고 SAVEPOINT 로 돌아가서 작업을
다시 수행한다.

START TRANSACTION - COMMIT, ROLLBACK, ROLLBACK TO, SAVE 442 p
```
```
* 트랜잭션 커맨드 예시 

start transaction;
insert into book balues (99, '데이터베이스', '한빛', 25000);

select bookname 'bookname1' from book
where bookid = 99;
savepoint a;
...
rollback to a; // rollback 만 사용하면 데이터가 전부 롤백된다. 

commit;
```
```
* 일관성 Consistency

테이블생성시 무결정 제약조건으로 테이블을 설계하여 데이터의 일관성을 유지하고 중복을 제거해야 한다. 다만 트랜잭션 수행 중
일시적으로 일관성이 유지되지 않는 상태가 발생한다.

예를 들면 A + B 의 계좌 금액이 20 만원이고 A 계좌에서 만원을 B 계좌로 입금 할 때 일시적으로 계좌 총 금액이 19 만원으로
줄어드는 일관성이 없는 상태가 발생한다. 
```
```
* 고립성 Isolation

데이터베이스는 공유가 목적이기 때문에 여러 트랜잭션이 동시에 데이터에 접근해서 작업이 수행 된다. 각 트랜잭션이 동시에
수행될 때 상호 간섭이나 데이터 충돌이 일어나지 않는 현상을 고립성이라고 한다.

변경 중인 임시 데이터를 다른 트랜잭션이 읽거나 쓰는 것을 제어한다.
```
```
* 지속성 Durability

트랜잭션이 정상적으로 완료 혹은 부분완료한 데이터는 반드시 데이터베이스에 기록되어야 한다. 이런 성질을 지속성이라고 한다.

DBMS 복구 시스템은 트랜잭션이 작업한 내용을 수시로 로그 데이터베이스에 기록하였다가 문제가 발생하면 로그 파일을 이용하여
복구 작업을 수행한다. 
```

DBMS 는 트랜잭션이 원자성, 일관성, 고립성, 지속성을 유지할 수 있도록 지원한다. 

## 동시성 제어

트랜잭션이 동시에 같은 데이터에 접근해서 작업을 수행할 때 데이터의 일관성을 해치지 않도록 트랜잭션의 데이터 접근을 제어하는 DBMS 기능을 동시성 제어라고 한다.

### 갱신 손실 문제

갱신 손실 문제는 두 개의 트랜잭션이 한 개의 데이터를 동시에 갱신update 할 때 발생한다. (절대 발생하면 안 되는 현상!)

### 락으로 갱신 손실 문제 해결하기
```
데이터에 락이 걸려있지 않으면 트랜잭션은 데이터에 락을 걸수 있다.

락은 트랜잭션이 다루는 데이터를 다른 트랜잭션이 접근하지 못하도록 막아 대기 상태로 만든다. 여러 트랜잭션이
같은 데이터에 접근할 때 먼저 락을 얻은 트랜잭션만 데이터를 갱신할 수 있으며 락을 얻지 못한 트랜잭션은 대기한다.

처음 트랜잭션에서 부분완료(COMMIT) 하면 대기하고있는 트랜잭션이 락을 획득해서 갱신을 순차적으로 수행할 수 있다.
```
#### + MySQL 에서 두 트랜잭션을 동시에 실행시키는 방법
```
workbench(DBMS) 메인 화면에서 + 버튼으로 두 개의 세션(데이터베이스 접속 단위) 을 만들어서 각각 사용하면 된다.
```
### 락의 유형
```
앞서 설명한 락을 사용하면 데이터를 갱신을 순차적으로 수행하기 때문에 갱신 손실 문제를 해결할 수 있다. 하지만 
트랜잭션을 대기 상태로 만드는 일은 사용자의 응답 시간에 영향을 미치기 때문에 가능한 최소화 해야 한다.
```
```
* 공유락 LS (읽기)

트랜잭션이 읽기를 할 때 사용하는 락을 공유락이라고 하며 다른 트랜잭션에서 같은 데이터를 읽기 요청 하더라도
공유락 상태에서는 접근을 허용한다. 하지만 LX 요청은 허용하지 않는다.
```
```
* 배타락 LX (읽기/쓰기)

트랜잭션이 락을 얻고 데이터를 갱신할 때 다른 트랜잭션의 읽기/쓰기 요청을 허용하지 않는다.
```
#### + 2 단계 락킹
```
락을 사용해서 갱신 손실을 해결하는 방법을 알아봤다 하지만 락을 사용해도 일관성이 깨질 수 있는 상황이 발생한다.

트랜잭션에서 갱신 중인 여러 개의 데이터 중 하나의 데이터에 락을 걸었다가 풀고 작업을 수행할 다른 데이터에 락을 거는 중간 과정에서
갱신된 데이터는 락이 해제되었기 때문에 다른 트랜잭션에게 중간 결과를 보일 수 있게 된다.

이때 다른 트랜잭션이 갱신된 데이터의 락을 획득해서 작업을 수행한다면 첫 트랜잭션이 데이터 작업을 수행할 때 일관성이 깨질 수 있다.
```
```
* 2 단계 락킹 기법으로 문제 해결하기

락에서 발생하는 일관성 문제를 해결하려면 중간에 락이 해제돼서 다른 트랜잭션이 접근하는 상황을 막아야 한다. 즉 트랜잭션이
수행할 모든 작업을 완료할 때까지 갱신한 데이터의 락을 해제하지 않아야 한다. 2 단계 락킹은 두 단계로 나뉜다.

- 확장 단계: 트랜잭션이 작업 수행에 필요한 락을 획득하는 단계로 이 단계에서는 이미 획득한 락을 해제하지 않는다.
- 수축 단계: 트랜잭션이 락을 해제하는 단계로, 이 단계에서는 새로운 락을 획득하지 않는다.

즉 수행할 작업이 남아 있으면 확장 단계가 유지되고 모든 작업을 마친 후 수축 단계로 들어간다.
```
#### ++ 2 단계 락킹에서 발생하는 데드락 문제 

2 단계 락킹을 사용해서 데이터의 일관성을 유지했다 하지만 이 방법에서도 문제가 발생할 수 있다.

```
데드락이란 두 개의 트랜잭션이 각각 자신의 데이터(서로 다른 데이터) 에 대해 락을 획득하고 상대방이 락을 획득한 데이터의 작업을
수행하기 위해 락을 요청하면 무한 대기 상태에 빠질 수 있다. 이러한 현상을 데드락 혹은 교착 상태라고 한다.


데드락이 발생하면 DBMS 는 트랜잭션 1 혹은 트랜잭션 2 의 작업 중 하나를 강제로 중지시키고 나머지 트랜잭션을 정상 실행하게 한다.
중지된 트랜잭션은 롤백된다.
```
## 트랜잭션 고립 수준

앞서 설명한 락의 상황은 두 트랜잭션이 서로 데이터를 갱신하는 상황을 해결하기 위한 것이다.

그러나 모든 트랜잭션이 갱신 작업만 하는 것은 아니다 데이터는 갱신보다 조회되는 상황이 더 많은데 조회 트랜잭션에서 락을 과도하게 사용하면 트랜잭션의 동시 진행 정도를 과도하게 막기 때문에 동시성을 높이기 위해서 좀 더 완화된 방법을 사용할 필요가 있다. 460 p 

### 트랜잭션 동시 실행 문제

트랜잭션이 읽기만 하면 갱신 손실 같은 심각한 문제는 발생하지 않지만 오손 읽기, 반복 불가능 읽기, 유령 데이터 읽기 문제 등이 발생할 수 있다.

#### + 트랜잭션 고립 수준 명령어
```
트랜잭션을 시작하면서 커맨드로 고립 수준을 정할 수 있다. 각각의 고립 수준에 따라 오손 읽기, 반복 불가능 읽기, 유령 데이터 읽기
문제를 야기한다.

0. READ UNCOMMITTED(Level=0) , SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED

가장 낮은 고립 수준으로 트랜잭션에서 SELECT 문을 사용할 때 조회한 데이터에 아무런 공유 락을 걸지 않는다 (UPDATE 시 배타락은 걸게 된다.)

이 레벨은 다른 트랜잭션의 공유락과 배타락이 걸린 데이터를 대기하지 않고 읽을 수 있으며 다른 트랜잭션이 COMMITT 하지 않은 실시간 데이터도
읽을 수 있다.

이 고립 레벨을 사용하면 오손 읽기, 반복 불가능 읽기, 유령 데이터 읽기 문제를 발생시킨다.


1. READ COMMITTED(Level=1) , SET TRANSACTION ISOLATION LEVEL READ COMMITTED

이 트랜잭션 수준은 데이터 SELECT 시 공유락을 사용하지만 조회가 끝나면 바로 해지된다.(트랜잭션 단위가 끝나기 전) UPDATE 는 배타락을 설정한다.
다른 트랜잭션이 설정한 공유락은 읽지만 배타락은 읽지 못한다.

이 고립 레벨을 사용하면 반복 불가능 읽기, 유령 데이터 읽기 문제가 발생한다.


2. REPEATABLE READ(Level=2), SET TRANSACTION ISOLATION LEVEL REPEATABLE READ

이 트랜잭션 수준은 데이터 SELECT 시 공유락을 트랜잭션이 종료될 때까지 유지하여 자신이 조회한 데이터를 갱신할 수 없도록 한다.
(갱신 할 수 없지 INSERT 는 가능함!!) UPDATE 는 배타락을 설정한다. 다른 트랜잭션이 설정한 공유락은 읽지만 배타락은 읽지 못한다.

데이터의 동시성이 낮아지기 때문에 특별한 상황이 아니라면 사용하지 않는다.

보통의 경우 유령 데이터읽기가 발생하지만, MySQL 에서는 이 트랜잭션 레벨을 사용해서 데이터를 조회하면 공유락을 걸지 않고
최초 조회한 데이터의 SNAPSHOT 을 만든 후 그 SNAPSHOT 을 조회 데이터로 사용하기 때문에 다른 세션에서 데이터를 수정하고

다시 조회 하더라도  유령 읽기가 발생하지 않는다. (트랜잭션 단위 내에서 스냅샷을 사용한다는 의미)


3. SERIALIZABL(Level=3), SET TRANSACTION ISOLATION LEVEL REPEATABLE READ

이 트랜잭션 수준은 SELECT 시 공유락을 걸고 트랜잭션을 끝까지 유지한다. UPDATE 는 다른 모든 경우와 마찬가지로 배타락을 설정한다.

다른 트랜잭션이 설정한 공유락은 읽을 수 있지만 배타락은 읽을 수 없으며 인덱스에 공유락을 설정하여 다른 트랜잭션의 INSERT 문이
금지된다. (고립수준이 가장 높으며 다른 트랜잭션으로부터  완벽하게 분리됨) 

트랜잭션에서 발생하는 어떤 문제도 발생하지 않는다.
```
#### ++ 트랜잭션 고립에서 발생하는 문제들
```
* 오손 읽기

오손읽기는 READ UNCOMMITTED 트랜잭션 레벨에서 발생한다. 이 레벨은 셀렉트 사용 시 공유락을 걸지 않으며 다른 트랜잭션의 공유락과
배타락이 걸린 트랜잭션을 읽을 수 있기 때문에 수정중인 데이터를 조회할 수 있다.

즉 수정중인 데이터를 조회했는데 롤백된다면 잘못된 데이터를 읽게 된다.
```
```
* 반복 불가능 읽기 

반복 불가능 읽기는 READ COMMITTED 트랜잭션 레벨에서 발생한다. 이 레벨은 셀렉트 사용 시 조회 후 트랜잭션이 끝나기 전에 락이 해제된다.

즉 처음 트랜잭션에서 조회한 데이터를 트랜잭션이 끝나기 전에 다른 트랜잭션에서 읽어와서 데이터를 수정하면 처음 조회한 트랜잭션이
세션 내에서 다시 기존 데이터를 조회했을 때 수정된 데이터가 읽어지기 때문에 반복적으로 데이터를 읽을 수 없는 문제가 발생한다.
```
```
* 유령 데이터 읽기

유령 데이터 읽기는 REPEATABLE READ 트랜잭션 레벨에서 발생한다. 이 레벨은 셀렉트 사용 시 트랜잭션이 끝날 때까지 락을 유지한다.
하지만 갱신(UPDATE) 작업이 아닌 데이터 삽입(INSERT) 는 락의 제한 없이 수행되기 때문에 트랜잭션 내에서 데이터를 다시 조회하면

다른 트랜잭션에서 삽입 한 유령 데이터를 읽을 수 있다. 참고로 MySQL 은 트랜잭션 내에서 처음 조회시 스냅샷을 유지하기 때문에
유령 데이터 읽기 문제가 발생하지 않는다.
```
## 회복

회복이란 데이터베이스에 문제가 발생했을 때 데이터베이스를 일관성 있는 상태로 되돌리는 DBMS 의 기능이다.

```
시스템 충돌, 미디어 장애, 응용 소프트웨어 오류로 발생하는 문제는 회복의 대상이 된다. 이 문제들은 두 가지 결과를 도출하는데
변경 중인 데이터를 갖고 있는 주기억장치가 손실되거나, 데이터베이스가 저장된 하드디스크가 손실되는 것이다.

그 외 자연재해 문제나 부주의 혹은 태업의 문제는 데이터 저장 장소를 이중화 하거나 하드웨어나 기억 장치를 이중화 해서 해결한다.
```

### 1. 트랜잭션과 회복 
```
트랜잭션은 데이터베이스 회복의 단위가 된다. 트랜잭션은 변경된 데이터(버퍼) 를 로그(임시 디스크) 에 기록한 후 데이터베이스에 반영한다.

트랜잭션 회복 관리자는 장애가 발생하면 로그의 내용을 참조하여 트랜잭션의 변경 내용을 모두 반영하거나 아니면 아예 반영하지 않는
방법으로 원자성과 지속성을 보장한다. 트랜잭션이 일단 COMMIT 한 내용은 로그를 이용하여 반드시 데이터베이스에 기록한다. 476 p
```
#### 로그 파일 (임시 디스크에 저장)
```
트랜잭션을 시작하고 데이터 변경 작업을 수행한다. 변경된 데이터는 주기억장치의 버퍼에 기록되며 변경이 발생할 때마다 변경 내용은 로그
파일에 저장된다(임시 디스크에 저장)

지연로딩에서 부분완료 COMMIT 이 발생했다는 것은  변경된 데이터가 모두 로그 파일에 기록되었다는 것을 의미한다. 변경되고 부분완료된
데이터들은 트랜잭션 종료까지 임의의 시점에 DBMS 가 운영 체제의 도움을 받아 데이터베이스(하드디스크) 에 기록한다.
```
#### 로그 파일을 사용해서 회복하기 

즉시 갱신을 기준으로 설명한다.

```
1. 트랜잭션의 재실행 (REDO)

문제가 발생한 후 시스템을 다시 가동했을 때, 로그 파일에 트랜잭션의 시작(START) 과 종료(COMMIT) 가 있는 경우이다.

COMMIT 이 있다는 것은 트랜잭션이 완료되었다는 것을 의미하지만, 버퍼의 내용이 데이터베이스에 기록되지 않았을 가능성이 있기 때문에
로그를 보면서 트랜잭션이 변경한 내용을 데이터베이스에 다시 기록하는 과정이 필요하다(REDO)
```
```
2. 트랜잭션의 취소(UNDO)

COMMIT 이 로그에 없는 경우(트랜잭션 실패) 트랜잭션을 취소해야 한다. 완료하지 못했지만 버퍼의 변경 내용이 데이터베이스에 기록되어
있을 가능성이 있기 때문에 로그를 보면서 트랜잭션이 변경한 내용을 데이터베이스에서 원상복구 시킨다 (UNDO)
```
#### 즉시 갱신과 지연 갱신에 대해서
```
1. 즉시 갱신

즉시 갱신은 '버퍼 -> 로그 파일', '버퍼 -> 데이터베이스' 작업이 부분 완료 전에 동시에 진행될 수 있으며, 부분완료 전에 버퍼의 갱신
데이터는 로그에 기록이 진행 된 상태이며 부분 완료 전에 버퍼의 일부 내용이 실제 데이터베이스에 반영될 수 있다.
```
```
2. 지연 갱신

지연 갱신은 '버퍼 -> 로그 파일' 이 모두 끝난 후 부분완료를 하고 이후 '버퍼 -> 데이터베이스' 작업을 진행하는 방법이다.

지연 갱신의 장점은 START 만 있는 로그 파일을 UNDO 할 필요 없다는 장점이 있다. 부분완료(COMMIT) 되지 않았다는 것은 버퍼의 내용이 실제
데이터베이스에 반영되지 않았다는 의미이기 때문이다.
```
### 2. 체크 포인트를 이용한 회복 

회복 시 많은 양의 로그를 검색하고 갱신하는 시간을 줄이기 위해 몇 십 분 단위로 데이터베이스와 트랜잭션 로그 파일을 동기화한 후 동기화한 시점을 로그 파일에 기록해두는 방법을 체크포인트라고 한다.

#### 체크 포인트 시점에 발생하는 작업들
```
- 주기억장치의 로그 레코드를 모두 하드디스크의 로그 파일에 저장한다.
- 버퍼에 있는 변경된 내용을 하드디스크의 데이터베이스에 저장한다(즉시갱신 경우)
- 체크포인트를 로그 파일에 표시한다.
```
```
1. 체크 포인트 이전에 COMMIT 기록이 있는 트랜잭션

아무 작업이 필요 없다. 체크 포인트가 나타나는 시점은 이미 변경 내용이 체크포인트에 의해 데이터베이스에 모두 기록된 후이기 때문(즉시,지연 둘 다)
```
```
2. 체크 포인트 이후에 COMMIT 기록이 있는 트랜잭션

REDO 를 진행한다. 체크 포인트 이후에 변경 내용이 데이터베이스에 반영되지 않았을 가능성이 있다. (즉시 갱신, 지연갱신)
```
```
3. 체크포인트 이후에 COMMIT 기록이 없는 트랜잭션의 경우

즉시 갱신의 경우 UNDO 를 진행한다. 버퍼의 내용이 반영됐을 수도 있기 때문에 원상복구 시킨다.
지연 갱신의 경우 아무것도 할 필요 없다. 지연 갱신은 COMMIT 이전에는 버퍼의 내용을 데이터베이스에 반영하지 않는다.
```
