# 트랜잭션 

트랜잭션은 DBMS 에서 데이터를 다루는 논리적인 작업의 단위이다. (DBMS 의 작업 단위)

## 트랜잭션의 개념 
```
- 트랜잭션은 데이터베이스 장애 발생시 데이터를 복구하는 작업의 단위가 된다.
- 데이터베이스에서 여러 작업이 동시에 같은 데이터를 다룰 때 트랜잭션은 이 작업을 서로 분리하는 단위가 된다.
- 트랜잭션은 전체가 수행되거나 또는 전혀 수행되지 않아야 한다.

참고로 데이터베이스의 데이터는 하드디스크에 저장되어 있으며, 데이터는 주기억장치 버퍼로 사본을 읽어와서 처리한다.
즉 데이터 작업은 주기억장치에서 수행되고 난 후에 하드디스크에 기록된다.
```
#### + MySQL 에서 트랜잭션이 처리되는 과정
```
START TRANSACTION 커맨드로 트랜잭션을 시작한다.(데이터 사본을 읽어온다.) -> 데이터 변경 작업 수행 -> 부분 완료(COMMIT)
-> 버퍼의 변경 내용을 하드디스크에 기록 -> 완료(COMMIT)

DBMS 는 부분완료까지 작업을 수행한 후 사용자에게 완료 사실을 알린다. 그리고 버퍼의 변경 내용을 하드디스크에 기록하는 작업은
따로 수행한다.

왜냐하면 DBMS 에서 동시에 많은 트랜잭션 수행시 각각의 트랜잭션 마다 하드디스크에 개별 접근하면 성능이 떨어지기 때문에
하드디스크에 접근하는 것을 일괄적으로 처리함으로써 사용자에게 빠른 응답성을 보장한다. 
```
### 트랜잭션의 성질 
```
* 원자성 Atomictiy

트랜잭션에 포함된 작업은 전부 수행되거나 아니면 전부 수행되지 않아야 한다.

MySQL 에서는 트랜잭션 제어 명령어를 사용해서 트랜잭션을 수동으로 시작하거나 또는 데이터를 변경하는 SQL 문이 나오면 자동으로
트랜잭션이 시작된다.

트랜잭션 종료는 직접 COMMIT 또는 ROLLBACK 문을 사용하거나 후자의 경우 DDL 문을 만날 때 자동으로 종료된다.

SAVE 문을 사용해서 세이브 포인트를 만들 수도 있다. 트랜잭션이 잘못 됐을 때 처음부터 다시 시작하지 않고 SAVEPOINT 로 돌아가서 작업을
다시 수행한다.

START TRANSACTION - COMMIT, ROLLBACK, ROLLBACK TO, SAVE 442 p
```
```
* 일관성 Consistency

테이블생성시 무결정 제약조건으로 테이블을 설계하여 데이터의 일관성을 유지하고 중복을 제거해야 한다. 다만 트랜잭션 수행 중
일시적으로 일관성이 유지되지 않는 상태가 발생한다.

예를 들면 A + B 의 계좌 금액이 20 만원이고 A 계좌에서 만원을 B 계좌로 입금 할 때 일시적으로 계좌 총 금액이 19 만원으로
줄어드는 일관성이 없는 상태가 발생한다. 
```
```
* 고립성 Isolation

데이터베이스는 공유가 목적이기 때문에 여러 트랜잭션이 동시에 데이터에 접근해서 작업이 수행 된다. 각 트랜잭션이 동시에
수행될 때 상호 간섭이나 데이터 충돌이 일어나지 않는 현상을 고립성이라고 한다.

변경 중인 임시 데이터를 다른 트랜잭션이 읽거나 쓰는 것을 제어한다.
```
```
* 지속성 Durability

트랜잭션이 정상적으로 완료 혹은 부분완료한 데이터는 반드시 데이터베이스에 기록되어야 한다. 이런 성질을 지속성이라고 한다.

DBMS 복구 시스템은 트랜잭션이 작업한 내용을 수시로 로그 데이터베이스에 기록하였다가 문제가 발생하면 로그 파일을 이용하여
복구 작업을 수행한다. 
```

DBMS 는 트랜잭션이 원자성, 일관성, 고립성, 지속성을 유지할 수 있도록 지원한다. 

## 동시성 제어

트랜잭션이 동시에 같은 데이터에 접근해서 작업을 수행할 때 데이터의 일관성을 해치지 않도록 트랜잭션의 데이터 접근을 제어하는 DBMS 기능을 동시성 제어라고 한다.

### 갱신 손실 문제

갱신 손실 문제는 두 개의 트랜잭션이 한 개의 데이터를 동시에 갱신update 할 때 발생한다. (절대 발생하면 안 되는 현상!)

### 락으로 갱신 손실 문제 해결하기
```
데이터에 락이 걸려있지 않으면 트랜잭션은 데이터에 락을 걸수 있다.

락은 트랜잭션이 다루는 데이터를 다른 트랜잭션이 접근하지 못하도록 막아 대기 상태로 만든다. 여러 트랜잭션이
같은 데이터에 접근할 때 먼저 락을 얻은 트랜잭션만 데이터를 갱신할 수 있으며 락을 얻지 못한 트랜잭션은 대기한다.

처음 트랜잭션에서 부분완료(COMMIT) 하면 대기하고있는 트랜잭션이 락을 획득해서 갱신을 순차적으로 수행할 수 있다.
```
#### + MySQL 에서 두 트랜잭션을 동시에 실행시키는 방법
```
workbench(DBMS) 메인 화면에서 + 버튼으로 두 개의 세션(데이터베이스 접속 단위) 을 만들어서 각각 사용하면 된다.
```
### 락의 유형
```
앞서 설명한 락을 사용하면 데이터를 갱신을 순차적으로 수행하기 때문에 갱신 손실 문제를 해결할 수 있다. 하지만 
트랜잭션을 대기 상태로 만드는 일은 사용자의 응답 시간에 영향을 미치기 때문에 가능한 최소화 해야 한다.
```
```
* 공유락 LS (읽기)

트랜잭션이 읽기를 할 때 사용하는 락을 공유락이라고 하며 다른 트랜잭션에서 같은 데이터를 읽기 요청 하더라도
공유락 상태에서는 접근을 허용한다. 하지만 LX 요청은 허용하지 않는다.
```
```
* 배타락 LX (읽기/쓰기)

트랜잭션이 락을 얻고 데이터를 갱신할 때 다른 트랜잭션의 읽기/쓰기 요청을 허용하지 않는다.
```
#### + 2 단계 락킹
```
락을 사용해서 갱신 손실을 해결하는 방법을 알아봤다 하지만 락을 사용해도 일관성이 깨질 수 있는 상황이 발생한다.

트랜잭션에서 갱신 중인 여러 개의 데이터 중 하나의 데이터에 락을 걸었다가 풀고 작업을 수행할 다른 데이터에 락을 거는 중간 과정에서
갱신된 데이터는 락이 해제되었기 때문에 다른 트랜잭션에게 중간 결과를 보일 수 있게 된다.

이때 다른 트랜잭션이 갱신된 데이터의 락을 획득해서 작업을 수행한다면 첫 트랜잭션이 데이터 작업을 수행할 때 일관성이 깨질 수 있다.
```
```
* 2 단계 락킹 기법으로 문제 해결하기

락에서 발생하는 일관성 문제를 해결하려면 중간에 락이 해제돼서 다른 트랜잭션이 접근하는 상황을 막아야 한다. 즉 트랜잭션이
수행할 모든 작업을 완료할 때까지 갱신한 데이터의 락을 해제하지 않아야 한다. 2 단계 락킹은 두 단계로 나뉜다.

- 확장 단계: 트랜잭션이 작업 수행에 필요한 락을 획득하는 단계로 이 단계에서는 이미 획득한 락을 해제하지 않는다.
- 수축 단계: 트랜잭션이 락을 해제하는 단계로, 이 단계에서는 새로운 락을 획득하지 않는다.

즉 수행할 작업이 남아 있으면 확장 단계가 유지되고 모든 작업을 마친 후 수축 단계로 들어간다.
```
#### ++ 2 단계 락킹에서 발생하는 데드락 문제 

2 단계 락킹을 사용해서 데이터의 일관성을 유지했다 하지만 이 방법에서도 문제가 발생할 수 있다.

```
데드락이란 두 개의 트랜잭션이 각각 자신의 데이터(서로 다른 데이터) 에 대해 락을 획득하고 상대방이 락을 획득한 데이터의 작업을
수행하기 위해 락을 요청하면 무한 대기 상태에 빠질 수 있다. 이러한 현상을 데드락 혹은 교착 상태라고 한다.


데드락이 발생하면 DBMS 는 트랜잭션 1 혹은 트랜잭션 2 의 작업 중 하나를 강제로 중지시키고 나머지 트랜잭션을 정상 실행하게 한다.
중지된 트랜잭션은 롤백된다.
```



